//Nathan Toschi Reis / 201865064C
//Felippe Rocha Lobo de Abreu / 201765185AC

%package "src.parsers";
%import "src.ast.*";
%import "src.beaver.*";

%class "MiniLangParser";

%terminals ID, INT, TYPE, FLOAT, CHAR, BOOL, NULL, NOT,
           MULT, PLUS, SUB, DIV, MOD, 
           EQ, IF, ELSE, ITERATE,
           RB, LB, AP, FP, AC, FC, SEMI, DOT,
           READ, PRINT, RETURN, CHARESCAPE,
           GREATER, LESSER, GREATEREQUAL, LESSEREQUAL, EQUALTO, DIF, AND,
           COMMA, COLON, DBCOLON, DATA, NEW;

%left DATA;
%left COMMA;
%left ELSE;
%left FP;
%left MULT, DIV, MOD;
%left PLUS, SUB;

%typeof ID = "String";
%typeof INT = "Integer";
%typeof TYPE = "String";
%typeof FLOAT = "float";
%typeof BOOL = "boolean";
%typeof CHAR = "Character";
%typeof NULL = "String";
%typeof CHARESCAPE = "String";
%typeof Exp = "Exp";
%typeof Pexp = "Exp";
%typeof Sexp = "Exp";
%typeof Mexp = "Exp";
%typeof Aexp = "Exp";
%typeof Rexp = "Exp";
%typeof Exps = "Exp";
%typeof Lvalue = "Lvalue";
%typeof Stmt = "Node";
%typeof Prog = "Node";
%typeof ParamList = "Node";
%typeof Param = "Node";
%typeof Func = "Node";
%typeof Return = "Node";
%typeof StmtList = "Node";
%typeof Ret = "Node";
%typeof Data = "Node";
%typeof Decl = "Node";

%goal Prog;

Prog = Stmt.l                 {: return new Prog(l);:}
     | Stmt.l Prog.r          {: return new Prog(l, r);:}
     | Func.l                 {: return new Prog(l);:}
     | Func.l Prog.r          {: return new Prog(l, r);:}
     | Data.l                 {: return new Prog(l);:}
     | Data.l Prog.r          {: return new Prog(l, r);:}               
     ;

Data = DATA TYPE.l AC Decl.t FC SEMI {:return new Data(new Type(l), t);:};

Decl = ID.l DBCOLON TYPE.t SEMI         {:return new Decl(l, new Type(t));:}
     | ID.l DBCOLON TYPE.t SEMI Decl.r  {:return new Decl(l, new Type(t), r);:}
     ;

StmtList = Stmt.l StmtList.r                                          {: return new StmtList(l, r);:}
     | Stmt.l                                                         {: return new StmtList(l);:} 
     ;

Stmt = ID.l EQ Exp.r SEMI                                             {: return new Attr((String)l, r);:}        
     | ITERATE AP Exp.l FP AC Stmt.r FC                               {: return new Iterate(l, r);:}
     | IF AP Exp.l FP StmtList.r ELSE StmtList.s                      {: return new IfElse(l, r, s);:}    
     | IF AP Exp.l FP StmtList.r                                      {: return new IfElse(l, r);:}                  
     | Exp SEMI
     | READ Lvalue.l SEMI                                             {:return new Read(l);:}       
     | PRINT Exp.e SEMI                                               {: return new Print(e);:}
     | RETURN Ret.l SEMI                                              {: return new GenRet(l);:}
     | Lvalue.l EQ Exp.r SEMI                                         {: return new Attr(l, r);:}
     | ID AP Exps FP LESSER Lvalue+ GREATER SEMI                      
     ;

Func = ID.a AP ParamList.b FP COLON Return.c AC StmtList.d FC         {:return new Func(new Lvalue(a), b, c, d);:}
     | ID.a AP ParamList.b FP AC StmtList.c FC                  {:return new Func(new Lvalue(a), b, c);:} 
     | ID.a AP FP AC StmtList.b FC                                    {:return new Func(new Lvalue(a), b);:}
     ;

Ret = Exp COMMA Ret
     | Exp
     ;

Return = TYPE.a COMMA Return.b         {:return new Return(new Type(a), b);:}
          | TYPE.a                      {:return new Return(new Type(a));:}
     ;

ParamList = Param.a COMMA ParamList.b  {:return new ParamList(a, b);:}
          | Param.a                    {:return new ParamList(a);:}
          ;

Param = ID.a DBCOLON TYPE.b                 {:return new Param(new Lvalue(a), new Type(b));:}
     ;

Lvalue = ID.l                                {:return new Lvalue(l);:}
     | Lvalue.l LB Exp.r RB                  {:return new Lvalue(l,r);:}
     | Lvalue.l DOT ID.r                     {:return new Lvalue(l,r);:}
     ;

Exp = Rexp
;

Rexp = Exp.l GREATER Exp.r                   {:return new Greater(l, r, 0);:}
     | AP Exp.l FP GREATER Exp.r             {:return new Greater(l, r, 1);:}
     | Exp.l GREATER AP Exp.r FP             {:return new Greater(l, r, 2);:}
     | AP Exp.l FP GREATER AP Exp.r FP       {:return new Greater(l, r, 3);:}
     | Exp.l LESSER Exp.r                    {:return new Lesser(l, r, 0);:}
     | AP Exp.l FP LESSER Exp.r              {:return new Lesser(l, r, 1);:} 
     | Exp.l LESSER AP Exp.r FP              {:return new Lesser(l, r, 2);:}
     | AP Exp.l FP LESSER AP Exp.r FP        {:return new Lesser(l, r, 3);:}         
     | Exp.l GREATEREQUAL Exp.r              {:return new GreaterEqual(l, r, 0);:}
     | AP Exp.l FP GREATEREQUAL Exp.r        {:return new GreaterEqual(l, r, 1);:}
     | Exp.l GREATEREQUAL AP Exp.r FP        {:return new GreaterEqual(l, r, 2);:}
     | AP Exp.l FP GREATEREQUAL AP Exp.r FP  {:return new GreaterEqual(l, r, 3);:}
     | Exp.l LESSEREQUAL Exp.r               {:return new LesserEqual(l, r, 0);:}
     | AP Exp.l FP LESSEREQUAL Exp.r         {:return new LesserEqual(l, r, 1);:}
     | Exp.l LESSEREQUAL AP Exp.r FP         {:return new LesserEqual(l, r, 2);:}
     | AP Exp.l FP LESSEREQUAL AP Exp.r FP   {:return new LesserEqual(l, r, 3);:}
     | Exp.l EQUALTO Exp.r                   {:return new Equal(l, r, 0);:}
     | AP Exp.l FP EQUALTO Exp.r             {:return new Equal(l, r, 1);:}
     | Exp.l EQUALTO AP Exp.r FP             {:return new Equal(l, r, 2);:}
     | AP Exp.l FP EQUALTO AP Exp.r FP       {:return new Equal(l, r, 3);:}
     | Exp.l DIF Exp.r                       {:return new Dif(l, r, 0);:}
     | AP Exp.l FP DIF Exp.r                 {:return new Dif(l, r, 1);:}
     | Exp.l DIF AP Exp.r FP                 {:return new Dif(l, r, 2);:}
     | AP Exp.l FP DIF AP Exp.r FP           {:return new Dif(l, r, 3);:}
     | Exp.l AND Exp.r                       {:return new And(l, r, 0);:}
     | AP Exp.l FP AND Exp.r                 {:return new And(l, r, 1);:}
     | Exp.l AND AP Exp.r FP                 {:return new And(l, r, 2);:}
     | AP Exp.l FP AND AP Exp.r FP           {:return new And(l, r, 3);:}
     | Aexp
;

Aexp = Exp.l PLUS  Exp.r                {:return new Add(l, r, 0);:}
     | AP Exp.l FP PLUS  Exp.r          {:return new Add(l, r, 1);:}  
     | Exp.l PLUS AP Exp.r FP           {:return new Add(l, r, 2);:}
     | AP Exp.l FP PLUS AP Exp.r FP     {:return new Add(l, r, 3);:}           
     | Exp.l SUB Exp.r                  {:return new Sub(l, r, 0);:}
     | AP Exp.l FP SUB Exp.r            {:return new Sub(l, r, 1);:}
     | Exp.l SUB AP Exp.r FP            {:return new Sub(l, r, 2);:}
     | AP Exp.l FP SUB AP Exp.r FP      {:return new Sub(l, r, 3);:}  
     | Mexp  
;
      
Mexp = Exp.l MULT Exp.r                 {:return new Mult(l, r, 0);:}  
     | AP Exp.l FP MULT Exp.r           {:return new Mult(l, r, 1);:}  
     | Exp.l MULT AP Exp.r FP           {:return new Mult(l, r, 2);:}
     | AP Exp.l FP MULT AP Exp.r FP     {:return new Mult(l, r, 3);:}   
     | Exp.l DIV Exp.r                  {:return new Div(l, r, 0);:}
     | AP Exp.l FP DIV Exp.r            {:return new Div(l, r, 1);:}
     | Exp.l DIV AP Exp.r FP            {:return new Div(l, r, 2);:}
     | AP Exp.l FP DIV AP Exp.r FP      {:return new Div(l, r, 3);:}
     | Exp.l MOD Exp.r                  {:return new Mod(l, r, 0);:}
     | AP Exp.l FP MOD Exp.r            {:return new Mod(l, r, 1);:}
     | Exp.l MOD AP Exp.r FP            {:return new Mod(l, r, 2);:}
     | AP Exp.l FP MOD AP Exp.r FP      {:return new Mod(l, r, 3);:}
     | Sexp                          
;

Sexp = NOT Exp.l         {:return new Not(l, 0);:}
     | NOT AP Exp.l FP   {:return new Not(l, 1);:}
     | BOOL.n            {:return new LiteralValue<Boolean>(n);:}                      
     | NULL.n            {:return new LiteralValue<String>(n);:}
     | CHARESCAPE.n      {:return new LiteralValue<String>(n);:}                  
     | INT.n             {:return new LiteralValue<Integer>(n);:}                   
     | FLOAT.n           {:return new LiteralValue<Float>(n);:}           
     | CHAR.n            {:return new LiteralValue<Character>(n);:}     
     | Pexp                                                     
;

Pexp = Lvalue.l                    {:return l;:}                    
     | NEW TYPE.l LB Exp.r RB      {:return new Inst(new Type(l), r);:}
     | NEW TYPE.l                  {:return new Inst(new Type(l));:}
     | ID.l AP Exps FP LB Exp RB  
     
;


Exps = Exp 
     | Exp Exps   
;