%package "parsers";
%import "ast.*";

%class "LangParser";

%terminals  ID, INT, TYPE, FLOAT, CHAR, BOOL, NULL, 
            ADD, MULT, SUB, DIV, SEP, PRINT, READ, RBRACK, 
            LBRACK, RPAREN, LPAREN, RES, EQUAL, EQUALTO, DIF, NOT, TRA,
            GREATER, LESSER, GREATEREQUAL, LESSEREQUAL, AND, OR, DIF, NOT COLON,
            DOUBLECOLON, SEMICOLON, RBRACE, LBRACE, IF, ELSE, ELSEIF, 
            RETURN, NEW, ITERATE;


//Prescedencia
%left FP;
%left MULT;
%left PLUS;

%typeof INT = "Integer";
%typeof FLOAT = "Float";
%typeof Expr = "Expr";
%typeof ID = "String";
%typeof Stmt = "Node";
%typeof StmtList = "Node";
%typeof Prog = "Node";

%goal Prog;

Prog = StmtList.s                     {:  return s;     :}  
     ;

StmtList = Stmt.s SEMICOLON StmtList.l     {: return new StmtList(s,l); :}
         | Stmt.s SEMICOLON                {: return s; :}  
         ;

Stmt = ID.s EQUAL Expr.e                             {: return new Attr(new ID(s), e); :}
     | Expr.e IF LB Stmt.s RB COLON LB Stmt.a RB  {: return new If(e,s,a);          :}
     | Expr.e IF LB Stmt.s RB                     {: return new If(e,s);            :}
     | Expr.e                                     {: return new Print(e);           :}
     ;

Exp = Expr.a AND Expr.b             {: return new And(a, b);               :}
     | Rexp

Rexp = | Expr.a GREATER Expr.b         {: return new Greater(a, b);           :}
     | Expr.a LESSER Expr.b          {: return new Lesser(a, b);              :}
     | Expr.a GREATEREQUAL Expr.b    {: return new GreaterEqual(a, b);        :}
     | Expr.a LESSEREQUAL Expr.b     {: return new LesserEqual(a, b);         :}
     | Expr.a EQUALTO Expr.b         {: return new Equal(a, b);               :}
     | Expr.a DIF Expr.b             {: return new Diff(a, b);                :}
     | Aexp

Aexp = Expr.a ADD  Expr.b            {: return new Add(a, b);               :}
     | Expr.a SUB Expr.b             {: return new Sub(a, b);               :}
     | Mexp

Mexp = Expr.a MULT  Expr.b           {: return new Mul(a,b);                :}
     | Expr.a DIV Expr.b             {: return new Div(a, b);               :}
     | Expr.a RES Expr.b             {: return new Res(a, b);               :}
     | Sexp

Sexp = Expr.a NOT                    {: return new Not(a);                  :}
     | Expr.a TRA                    {: return new Tra(a);                  :}
     | true
     | false
     | null
     | INT
     | FLOAT
     | CHAR
     | Pexp

Pexp = lvalue
     | ‘(’ Exp ‘)’
     | new type [ ‘[’ Exp ‘]’ ]
     | ID ‘(’ [exps] ‘)’ ‘[’ exp ‘]’

Lvalue = ID.v 
     | NUM.n                         {: return new Num(n);                  :}
     | AP Expr.e FP                  {: return e;                           :}
     ;

Exps = Exp { , Exp }




//data
DataDeclaration = DATA TYPE LBRACE dataBody RBRACE;

DataBody =  variableDeclarationList;

VariableDeclarationList = variableDeclaration variableDeclaration*;

VariableDeclaration = ID DOUBLECOLON typeOrLiteral SEMICOLON;


TypeOrLiteral = TYPE | STRING | INT | FLOAT | CHAR | BOOL; {: return typeOrLiteral() :}


//function
Function = ID  LPAREN parameter | parameterList  RPAREN LBRACE functionBody RBRACE;

ParametroList = parametro*;

Parametro = typeOrLiteral ID COLON | null;

functionBody = body RETURN typeOrLiteral;
//
