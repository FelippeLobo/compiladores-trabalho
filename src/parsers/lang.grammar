//Nathan Toschi Reis / 201865064C
//Felippe Rocha Lobo de Abreu / 201765185AC

%package "src.parsers";
%import "src.ast.*";
%import "src.beaver.*";

%class "MiniLangParser";

%terminals ID, INT, TYPE, FLOAT, CHAR, BOOL, NULL, NOT,   
           MULT, PLUS, SUB, DIV, RES, 
           EQ, IF, ELSE, ITERATE,
           RB, LB, AP, FP, AC, FC, SEMI, DOT,
           READ, PRINT, RETURN,
           GREATER, LESSER, GREATEREQUAL, LESSEREQUAL, EQUALTO, DIF,
           COMMA, COLON, DBCOLON, DATA, NEW;

%left DATA;   
%left COMMA;
%left ELSE;
%left FP;
%left MULT, DIV, RES;
%left PLUS, SUB;


%typeof ID = "String";
%typeof INT = "Integer";
%typeof TYPE = "String";
%typeof FLOAT = "float";
%typeof BOOL = "boolean";
%typeof CHAR = "char";
%typeof Exp = "Exp";
%typeof Pexp = "Exp";
%typeof Sexp = "Exp";
%typeof Mexp = "Exp";
%typeof Aexp = "Exp";
%typeof Rexp = "Exp";
%typeof Exps = "Exp";
%typeof Lvalue = "Lvalue";
%typeof Stmt = "Node";
%typeof Prog = "Node";
%typeof ParamList = "Node";
%typeof Param = "Node";
%typeof Func = "Node";
%typeof Return = "Node";
%typeof StmtList = "Node";
%typeof Ret = "Node";
%typeof Data = "Node";
%typeof Decl = "Node";



%goal Prog;

Prog = Stmt.l SEMI        {: return new Prog(l);:}
     | Stmt.l SEMI Prog.r {: return new Prog(l, r);:}
     | Func.l             {: return new Prog(l);:}
     | Func.l Prog.r      {: return new Prog(l, r);:}
     | Data.l            {: return new Prog(l);:}
     | Data.l Prog.r      {: return new Prog(l, r);:}               
     ;

Data = DATA TYPE.l AC Decl.t FC SEMI {:return new Data(new Type(l), t);:};

Decl = ID.l DBCOLON TYPE.t SEMI         {:return new Decl(new Lvalue(l), new Type(t));:}
     | ID.l DBCOLON TYPE.t SEMI Decl.r  {:return new Decl(new Lvalue(l), new Type(t), r);:}
     ;

Stmt = ID.l EQ Exp.r                   {: return new Attr((String)l, r);:}
     | IF AP Exp FP Stmt
     | IF AP Exp FP Stmt ELSE Stmt             
     | ITERATE AP Exp FP Stmt                        
     | Exp
     | READ Lvalue.l                     {:return new Read(l);:}
     | PRINT Exp.e                       {: return new Print(e);:} 
     | RETURN Ret 
     | Lvalue.l EQ Exp.r                    {: return new Attr(l, r);:}
     | ID AP Exps FP LESSER Lvalue+ GREATER                      
     ;

Func = ID.a AP ParamList.b FP COLON Return.c AC StmtList.d FC {:return new Func(new Lvalue(a), b, c, d);:}
     ;

StmtList = Stmt.l SEMI StmtList.r     {: return new StmtList(l, r);:}
         | Stmt.l SEMI                {: return new StmtList(l);:}
         ;

Ret = Exp COMMA Ret
     | Exp
     ;

Return = TYPE.a COMMA Return.b         {:return new Return(new Type(a), b);:}
          | TYPE.a                      {:return new Return(new Type(a));:}
     ;

ParamList = Param.a COMMA ParamList.b  {:return new ParamList(a, b);:}
          | Param.a                    {:return new ParamList(a);:}
          ;

Param = ID.a DBCOLON TYPE.b                 {:return new Param(new Lvalue(a), new Type(b));:}
     ;

Lvalue = ID.l                                {:return new Lvalue(l);:}
     | Lvalue.l LB Exp.r RB                  {:return new Lvalue(l,r);:}
     | Lvalue.l DOT ID.r                     {:return new Lvalue(l,r);:}
     ;

Exp = Rexp
;

Rexp = Exp GREATER Exp
     | Exp LESSER Exp          
     | Exp GREATEREQUAL Exp    
     | Exp LESSEREQUAL Exp     
     | Exp EQUALTO Exp         
     | Exp DIF Exp  
     | Aexp
;

Aexp = Exp.l PLUS  Exp.r      {:return new Add(l, r);:}          
     | Exp.l SUB  Exp.r       {:return new Sub(l, r);:}  
     | Mexp  
;
      
Mexp = Exp MULT  Exp           
     | Exp DIV  Exp
     | Exp RES  Exp  
     | Sexp                          
;

Sexp = Exp NOT
     | BOOL.n            {:return new LiteralValue<Boolean>(n);:}                      
     | NULL                                   
     | INT.n             {:return new LiteralValue<Integer>(n);:}                   
     | FLOAT.n           {:return new LiteralValue<Float>(n);:}           
     | CHAR.n            {:return new LiteralValue<Character>(n);:}     
     | Pexp                                                     
;

Pexp = Lvalue.l                  {:return l;:}
     | AP Exp FP                        
     | NEW TYPE.l LB Exp.r RB     {:return new Inst(new Type(l), r);:}
     | NEW TYPE.l                 {:return new Inst(new Type(l));:}
     | ID.l AP Exps FP LB Exp RB  
     
;


Exps = Exp 
     | Exp Exps   
;

