%package "parsers";
%import "ast.*";

%class "LangParser";

%terminals  ID, INT, TYPE, FLOAT, CHAR, BOOL, NULL, 
            ADD, MULT, SUB, DIV, SEP, PRINT, READ, DEFOP, RBRACK, 
            LBRACK, RPAREN, LPAREN, RES, EQUAL, EQUALTO, DIF, NOT, 
            GREATER, LESSER, GREATEREQUAL, LESSEREQUAL, AND, OR, COLON,
            DOUBLECOLON, SEMICOLON, RBRACE, LBRACE, IF, ELSE, ELSEIF, 
            RETURN, NEW, ITERATE;
            PRIVATE, PUBLIC, PROTECTED;


//Prescedencia
%left RPAREN;
%left MULT, DIV;
%left ADD, SUB;

%typeof INT = "Integer";
%typeof FLOAT = "Float";
%typeof Exp = "Exp";
%typeof ID = "String";
%typeof Cmd = "Node";
%typeof CmdList = "Node";
%typeof Prog = "Node";

%goal Prog;

Prog = CmdList.s                     {:  return s;     :}  
     ;

CmdList = Cmd.s SEMICOLON CmdList.l     {: return new CmdList(s,l); :}
         | Cmd.s SEMICOLON                {: return s; :}  
         ;

Cmd = LBRACE Cmd.c RBRACE                       {: return c;                     :}   
     | IF LPAREN Exp.e RPAREN Cmd.c             {: return new If(e, c);       :}   
     | IF LPAREN Exp.e RPAREN Cmd.c ELSE Cmd.m  {: return new If(e, c, m);    :}          
     | ITERATE LPAREN Exp.e RPAREN Cmd.c        {: return new Iterate(e, c);     :}
     | READ lvalue.l SEMICOLON                  {: return new Read(l);     :}
     | PRINT exp.e SEMICOLON                    {: return new Print(e);     :}
     | RETURN exp.e ?{',' exp.e} SEMICOLON      {: return new Return(e);     :}
     | lvalue.l = exp.e SEMICOLON               {: return new Attr(l, e);     :}
     | ID.x LPAREN Exps.e RPAREN LESSER lvalue.v ?{',' lvalue.l} GREATER SEMICOLON                          
     ;

Lvalue =    ID.i {: return new ID(i);     :}
          | Lvalue.v LBRACK Exp.e RBRACK   {: return new Call(v, e); :}
          | Lvalue.v '.' ID.i;   {: return new Call(v, i); :}
      
Exp = Exp.a MULT  Exp.b           {: return new Mul(a,b);                :}
     | Exp.a PLUS  Exp.b           {: return new Add(a, b);               :}
     | ID.v                          {: return new ID(v);                   :}
     | NUM.n                         {: return new Num(n);                  :}
     | AP Exp.e FP                  {: return e;                  :}
     ;




//data
DataDeclaration = DATA ID LBRACE DataBody.d RBRACE;

DataBody =  variableDeclarationList;

VariableDeclarationList = variableDeclaration variableDeclaration*;

VariableDeclaration = ID DOUBLECOLON typeOrLiteral SEMICOLON;


TypeOrLiteral = TYPE | STRING | INT | FLOAT | CHAR | BOOL; {: return typeOrLiteral() :}


//function
Function = ID  LPAREN parameter | parameterList  RPAREN LBRACE functionBody RBRACE;

ParametroList = parametro*;

Parametro = typeOrLiteral ID COLON | null;

FunctionBody = variasCoisa RETURN typeOrLiteral;
//










data Carro { 
    modelo :: String;
    placa :: String;
    serie :: Int;
}

     Expr
   /   |         \
Expr MULT        Expr
|           /       |   \
ID          Expr PLUS Expr
|           |           |
A           Num         ID
            |           |
            2           B