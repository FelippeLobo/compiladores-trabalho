//Nathan Toschi Reis / 201865064C
//Felippe Rocha Lobo de Abreu / 201765185AC

%package "src.parsers";
%import "src.ast.*";
%import "src.beaver.*";

%class "MiniLangParser";

%terminals ID, INT, TYPE, FLOAT, CHAR, BOOL, NULL, NOT,
           MULT, PLUS, SUB, DIV, MOD, 
           EQ, IF, ELSE, ITERATE,
           RB, LB, AP, FP, AC, FC, SEMI, DOT,
           READ, PRINT, RETURN,
           GREATER, LESSER, GREATEREQUAL, LESSEREQUAL, EQUALTO, DIF, AND,
           COMMA, COLON, DBCOLON, DATA, NEW;

%left DATA;   
%left COMMA;
%left ELSE;
%left FP;
%left MULT, DIV, RES;
%left PLUS, SUB;

%typeof ID = "String";
%typeof INT = "Integer";
%typeof TYPE = "String";
%typeof FLOAT = "float";
%typeof BOOL = "boolean";
%typeof CHAR = "Character";
%typeof NULL = "String";
%typeof Exp = "Exp";
%typeof Pexp = "Exp";
%typeof Sexp = "Exp";
%typeof Mexp = "Exp";
%typeof Aexp = "Exp";
%typeof Rexp = "Exp";
%typeof Exps = "Exp";
%typeof Lvalue = "Lvalue";
%typeof Stmt = "Node";
%typeof Prog = "Node";
%typeof ParamList = "Node";
%typeof Param = "Node";
%typeof Func = "Node";
%typeof Return = "Node";
%typeof StmtList = "Node";
%typeof Ret = "Node";
%typeof Data = "Node";
%typeof Decl = "Node";

%goal Prog;

Prog = Stmt.l                 {: return new Prog(l);:}
     | Stmt.l Prog.r          {: return new Prog(l, r);:}
     | Func.l                 {: return new Prog(l);:}
     | Func.l Prog.r          {: return new Prog(l, r);:}
     | Data.l                 {: return new Prog(l);:}
     | Data.l Prog.r          {: return new Prog(l, r);:}               
     ;

Data = DATA TYPE.l AC Decl.t FC SEMI {:return new Data(new Type(l), t);:};

Decl = ID.l DBCOLON TYPE.t SEMI         {:return new Decl(l, new Type(t));:}
     | ID.l DBCOLON TYPE.t SEMI Decl.r  {:return new Decl(l, new Type(t), r);:}
     ;

StmtList = Stmt.l StmtList.r                                          {: return new StmtList(l, r);:}
     | Stmt.l                                                         {: return new StmtList(l);:} 
     ;

Stmt = ID.l EQ Exp.r SEMI                                             {: return new Attr((String)l, r);:}        
     | ITERATE AP Exp.l FP Stmt.r                                     {: return new Iterate(l, r);:}
     | IF AP Exp.l FP StmtList.r ELSE StmtList.s                      {: return new IfElse(l, r, s);:}    
     | IF AP Exp.l FP StmtList.r                                      {: return new IfElse(l, r);:}                  
     | Exp SEMI
     | READ Lvalue.l SEMI                                             {:return new Read(l);:}       
     | PRINT Exp.e SEMI                                               {: return new Print(e);:} 
     | RETURN Ret.l SEMI                                              {: return new GenRet(l);:}
     | Lvalue.l EQ Exp.r SEMI                                         {: return new Attr(l, r);:}
     | ID AP Exps FP LESSER Lvalue+ GREATER SEMI                      
     ;

     

Func = ID.a AP ParamList.b FP COLON Return.c AC StmtList.d FC         {:return new Func(new Lvalue(a), b, c, d);:}
     | ID.a AP FP AC StmtList.b FC                                    {:return new Func(new Lvalue(a), b);:}
     ;

Ret = Exp COMMA Ret
     | Exp
     ;

Return = TYPE.a COMMA Return.b         {:return new Return(new Type(a), b);:}
          | TYPE.a                      {:return new Return(new Type(a));:}
     ;

ParamList = Param.a COMMA ParamList.b  {:return new ParamList(a, b);:}
          | Param.a                    {:return new ParamList(a);:}
          ;

Param = ID.a DBCOLON TYPE.b                 {:return new Param(new Lvalue(a), new Type(b));:}
     ;

Lvalue = ID.l                                {:return new Lvalue(l);:}
     | Lvalue.l LB Exp.r RB                  {:return new Lvalue(l,r);:}
     | Lvalue.l DOT ID.r                     {:return new Lvalue(l,r);:}
     ;

Exp = Rexp
;

Rexp = Exp.l GREATER Exp.r            {:return new Greater(l, r);:}
     | Exp.l LESSER Exp.r             {:return new Lesser(l, r);:}       
     | Exp.l GREATEREQUAL Exp.r       {:return new GreaterEqual(l, r);:}
     | Exp.l LESSEREQUAL Exp.r        {:return new LesserEqual(l, r);:}
     | Exp.l EQUALTO Exp.r            {:return new Equal(l, r);:}
     | Exp.l DIF Exp.r                {:return new Dif(l, r);:}
     | Exp.l AND Exp.r                {:return new And(l, r);:}
     | Aexp
;

Aexp = Exp.l PLUS  Exp.r      {:return new Add(l, r);:}          
     | Exp.l SUB  Exp.r       {:return new Sub(l, r);:}  
     | Mexp  
;
      
Mexp = Exp.l MULT Exp.r       {:return new Mult(l, r);:}      
     | Exp.l DIV Exp.r        {:return new Div(l, r);:}
     | Exp.l MOD Exp.r        {:return new Mod(l, r);:}
     | Sexp                          
;

Sexp = Exp NOT
     | BOOL.n            {:return new LiteralValue<Boolean>(n);:}                      
     | NULL.n            {:return new LiteralValue<String>(n);:}                  
     | INT.n             {:return new LiteralValue<Integer>(n);:}                   
     | FLOAT.n           {:return new LiteralValue<Float>(n);:}           
     | CHAR.n            {:return new LiteralValue<Character>(n);:}     
     | Pexp                                                     
;

Pexp = Lvalue.l                    {:return l;:}
     | AP Exp FP                        
     | NEW TYPE.l LB Exp.r RB      {:return new Inst(new Type(l), r);:}
     | NEW TYPE.l                  {:return new Inst(new Type(l));:}
     | ID.l AP Exps FP LB Exp RB  
     
;


Exps = Exp 
     | Exp Exps   
;