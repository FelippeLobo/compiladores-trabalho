%package "parsers";
%import "ast.*";

%class "LangParser";

%terminals  ID, INT, TYPE, FLOAT, CHAR, BOOL, NULL, 
            ADD, MULT, SUB, DIV, SEP, PRINT, READ, DEFOP, RBRACK, 
            LBRACK, RPAREN, LPAREN, RES, EQUAL, EQUALTO, DIF, NOT, TRA,
            GREATER, LESSER, GREATEREQUAL, LESSEREQUAL, AND, OR, DIF, NOT COLON,
            DOUBLECOLON, SEMICOLON, RBRACE, LBRACE, IF, ELSE, ELSEIF, 
            RETURN, NEW, ITERATE;
            PRIVATE, PUBLIC, PROTECTED;


//Prescedencia
%left RPAREN;
%left MULT, DIV;
%left ADD, SUB;

%typeof INT = "Integer";
%typeof FLOAT = "Float";
%typeof Exp = "Exp";
%typeof ID = "String";
%typeof Cmd = "Node";
%typeof CmdList = "Node";
%typeof Prog = "Node";

%goal Prog;

Prog = CmdList.s                     {:  return s;     :}  
     ;

CmdList = Cmd.s SEMICOLON CmdList.l     {: return new CmdList(s,l); :}
         | Cmd.s SEMICOLON                {: return s; :}  
         ;

Cmd = LBRACE Cmd.c RBRACE                       {: return c;                     :}   
     | IF LPAREN Exp.e RPAREN Cmd.c             {: return new If(e, c);       :}   
     | IF LPAREN Exp.e RPAREN Cmd.c ELSE Cmd.m  {: return new If(e, c, m);    :}          
     | ITERATE LPAREN Exp.e RPAREN Cmd.c        {: return new Iterate(e, c);     :}
     | READ lvalue.l SEMICOLON                  {: return new Read(l);     :}
     | PRINT exp.e SEMICOLON                    {: return new Print(e);     :}
     | RETURN exp.e ?{',' exp.e} SEMICOLON      {: return new Return(e);     :}
     | lvalue.l = exp.e SEMICOLON               {: return new Attr(l, e);     :}
     | ID.x LPAREN Exps.e RPAREN LESSER lvalue.v ?{',' lvalue.l} GREATER SEMICOLON                          
     ;

Lvalue =    ID.i {: return new ID(i);     :}
          | Lvalue.v LBRACK Exp.e RBRACK   {: return new Call(v, e); :}
          | Lvalue.v '.' ID.i;   {: return new Call(v, i); :}
      

Exp = Expr.a AND Expr.b             {: return new And(a, b);               :}
     | Rexp

Rexp = | Expr.a GREATER Expr.b         {: return new Greater(a, b);           :}
     | Expr.a LESSER Expr.b          {: return new Lesser(a, b);              :}
     | Expr.a GREATEREQUAL Expr.b    {: return new GreaterEqual(a, b);        :}
     | Expr.a LESSEREQUAL Expr.b     {: return new LesserEqual(a, b);         :}
     | Expr.a EQUALTO Expr.b         {: return new Equal(a, b);               :}
     | Expr.a DIF Expr.b             {: return new Diff(a, b);                :}
     | Aexp

Aexp = Expr.a ADD  Expr.b            {: return new Add(a, b);               :}
     | Expr.a SUB Expr.b             {: return new Sub(a, b);               :}
     | Mexp

Mexp = Expr.a MULT  Expr.b           {: return new Mul(a,b);                :}
     | Expr.a DIV Expr.b             {: return new Div(a, b);               :}
     | Expr.a RES Expr.b             {: return new Res(a, b);               :}
     | Sexp

Sexp = Expr.a NOT                    {: return new Not(a);                  :}
     | Expr.a TRA                    {: return new Tra(a);                  :}
     | true
     | false
     | null
     | INT
     | FLOAT
     | CHAR
     | Pexp

Pexp = lvalue
     | ‘(’ Exp ‘)’
     | new type [ ‘[’ Exp ‘]’ ]
     | ID ‘(’ [exps] ‘)’ ‘[’ exp ‘]’

Lvalue = ID.v 
     | NUM.n                         {: return new Num(n);                  :}
     | AP Expr.e FP                  {: return e;                           :}
     ;

Exps = Exp { , Exp }




//data
DataDeclaration = DATA ID.i LBRACE DataBody.d RBRACE {: return new Data(i, d);                  :} ;

DataBody =  variableDeclarationList;

VariableDeclarationList = variableDeclaration variableDeclaration*;

VariableDeclaration = ID DOUBLECOLON typeOrLiteral SEMICOLON;


TypeOrLiteral = TYPE | STRING | INT | FLOAT | CHAR | BOOL; {: return typeOrLiteral() :}


//function
Function = ID  LPAREN parameter | parameterList  RPAREN LBRACE functionBody RBRACE;

ParametroList = parametro*;

Parametro = typeOrLiteral ID COLON | null;

functionBody = body RETURN typeOrLiteral;
//
