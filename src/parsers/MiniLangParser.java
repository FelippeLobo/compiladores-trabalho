package src.parsers;

import src.ast.*;
import java.util.ArrayList;
import src.beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "lang.grammar".
 */
public class MiniLangParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pbLsbiLKKK$kwzfGkM0aLAnRQlfLKej4ziQMkXBgqAY58N4AeYeY9Qm8A0ACegI6d59L4" +
		"8VzH8ed59z9yc9YA2rWKLDrHSwYwbBg22u8BZT#SDt7bptxiy6qqmjFdcd3dVcJDdPkui3t" +
		"2Uma0Ken$wuZWSZro4K812d80XA1LVYx#GXbCm0cKenp1Ke1Brqd###DF7d8NBSJLcOXRc#" +
		"BX3ZFWzFeVf2ECa3CN9gCBDc83n6XStInmRmFNH8WuFy8i$1mAdeOVaUw31o7nqG4HlnFim" +
		"9S0lIyjmMe3VZ03kXW3krgwC#eXcZ5KG1n9PXSJZ#UhPsWfvyKRY7F67LZzSbFvne$mMTmS" +
		"uE0OskY75j8iDI8fbHpgIOzepa2hjapHxZgQVZvweHIyinwLeCJ8tT#L4d6vuz1Q$OedFxr" +
		"haQPOQyRpFez5dMUQBVRJNzHKpkLhKOInNB7eMh$pNSxXHYw$hJUxtYxau4sTZWTHlGhx63" +
		"z3q8aq$KTC7QVfWJI$Hz6fDFrNJHsdwPPf#XQPVe#cpDVqMJJy3OyMNk4HyZjkn26Dm7lV1" +
		"1LY1Sx4G5#8YZCDaN8MBCHNNSRwlnppn3HQATj6ExhBCn6AiHARuIdo1fLY5sn3vQ#P$6hf" +
		"p5wVpziZW7kk5tlJkmpkhBqz#mEB#TkHUJkRkJELfvFeNnc26y$JAvkdLd#UNoNcClvt73U" +
		"HS5tEEXt1kI#NeFIueo$YS7Z4dm2y#0tuNbkGjN#P50UsypFC3Uquqmw1HTfNxVpBcAY2XL" +
		"KWydbdNLyYBbykx0m5VVDUYc3kWMkx$CfzzH1nxVXnxGGoxhfSprmf#ArKyLuCoZ#nAqwDQ" +
		"VkD#FzsIUrYFsB6Fzhe#GoPNmJcrk6BcBFwNEUXwbln#AxclIdcJHlHulaUoRdF48POvt0U" +
		"5rBFasxEGfuN35$WmoMNn6xVvBh3aBw8iCkvuGx8SG1#BPOYjGcJoXVpZhYlWxcvT6hbhYu" +
		"cxYGnUWLCeUHTQzrDMKMu4d2NKxwNU5l6ttWOxfDp5uXxghDWZgO#9y7OzYnsK4oZtK4wch" +
		"qKvZP9zs4sKxCEUJpc8SZ5b1ULA#lUal8koXNAjYlU0ae$GhyxL4mNRFCcYGUbyDTXFKvcf" +
		"yId49exHvTefbx4FvcDl8BaWukCqApdNQsSznFeiOZfn1p67nlievob#ech3zupTHcJJra2" +
		"u$kwSlKTo3UkSMsUHykKSsnrK7gEzcVNPbElL6ZsdVDOIAIhttIosA7q$xSjTdSkxZxhhku" +
		"BWl3lkJRHTjPzAh2Curyugnd#SiaLnZSHwefLOJJoix7UgCJsev1DAFgFaPcrUriHU1wj3Z" +
		"MEKPyCwnJKgkLh9RMfCoQf$vUyShAShcQbajf9vIXR5oY48R3FOg0yryjzwKEVyTZAtlSgl" +
		"yX$qCKcDEq#BkzFJxKVfKsEqgLFSiuPzj6f$GF4P1Zz3q#krFZgZ$UpTcjzu8qQJvjVFuCR" +
		"57YDQuViJcsIvtx3#Gdn4R2S#93uWtYUs4TmTuXs29utOIhn9l26sY8$5k#8jyRfuJRmgNX" +
		"4lYpRnaepreegvETANgksKvQV49qG7VszqHcMmG#mHUrLs6yKB6lFp8UqdWljCx9Ar7sNvW" +
		"oo$ZuhrNLJjMqt$JFPGovUHnRUE2zidotYdLKjquql3bg#DCEjXtdDXsiAyxSAqXxaPF2Jn" +
		"bur5kFPKlgBIY6JUT0vXyUHtvEdllg3AAQieI#KjaKGul6SitZHE02pU38w2nHl9qM3nVh8" +
		"9AoPAw5F2VahaAy25pJU1XPg$0GUiDX0=");

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};

	private final Action[] actions;

	public MiniLangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = Prog
			new Action() {	// [1] Prog = Stmt.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [2] Prog = Stmt.l Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			new Action() {	// [3] Prog = Func.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [4] Prog = Func.l Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			new Action() {	// [5] Prog = Data.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [6] Prog = Data.l Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			RETURN4,	// [7] Data = ID AC Decl FC; returns 'FC' although none is marked
			RETURN4,	// [8] Decl = ID DBCOLON TYPE SEMI; returns 'SEMI' although none is marked
			RETURN5,	// [9] Decl = ID DBCOLON TYPE SEMI Decl; returns 'Decl' although none is marked
			new Action() {	// [10] StmtList = Stmt.l StmtList.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final Node r = (Node) _symbol_r.value;
					 return new StmtList(l, r);
				}
			},
			new Action() {	// [11] StmtList = Stmt.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new StmtList(l);
				}
			},
			new Action() {	// [12] Stmt = ID.l EQ Exp.r SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					 return new Attr((String)l, r);
				}
			},
			new Action() {	// [13] Stmt = ITERATE AP Exp.l FP Stmt.r SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 3];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final Node r = (Node) _symbol_r.value;
					 return new Iterate(l, r);
				}
			},
			new Action() {	// [14] Stmt = IF AP Exp.l FP StmtList.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 3];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final Node r = (Node) _symbol_r.value;
					 return new IfElse(l, r);
				}
			},
			new Action() {	// [15] Stmt = IF AP Exp.l FP StmtList.r ELSE StmtList.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 3];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final Node r = (Node) _symbol_r.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final Node s = (Node) _symbol_s.value;
					 return new IfElse(l, r, s);
				}
			},
			RETURN2,	// [16] Stmt = Exp SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [17] Stmt = READ Lvalue SEMI; returns 'SEMI' although none is marked
			new Action() {	// [18] Stmt = PRINT Exp.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 return new Print(e);
				}
			},
			new Action() {	// [19] Stmt = RETURN Ret.l SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 2];
					final Node l = (Node) _symbol_l.value;
					 return new GenRet(l);
				}
			},
			RETURN4,	// [20] Stmt = Lvalue EQ Exp SEMI; returns 'SEMI' although none is marked
			new Action() {	// [21] lst$Lvalue = Lvalue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [22] lst$Lvalue = lst$Lvalue Lvalue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			RETURN8,	// [23] Stmt = ID AP Exps FP LESSER lst$Lvalue GREATER SEMI; returns 'SEMI' although none is marked
			new Action() {	// [24] Func = ID.a AP ParamList.b FP COLON Return.c AC StmtList.d FC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final String a = (String) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Node b = (Node) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final Node c = (Node) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 8];
					final Node d = (Node) _symbol_d.value;
					return new Func(new Var(a), b, c, d);
				}
			},
			new Action() {	// [25] Func = ID.a AP FP AC StmtList.d FC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final String a = (String) _symbol_a.value;
					final Symbol _symbol_d = _symbols[offset + 5];
					final Node d = (Node) _symbol_d.value;
					return new Func(new Var(a), d);
				}
			},
			RETURN3,	// [26] Ret = Exp COMMA Ret; returns 'Ret' although none is marked
			Action.RETURN,	// [27] Ret = Exp
			RETURN3,	// [28] Return = TYPE COMMA Return; returns 'Return' although none is marked
			Action.RETURN,	// [29] Return = TYPE
			RETURN3,	// [30] ParamList = Param COMMA ParamList; returns 'ParamList' although none is marked
			Action.RETURN,	// [31] ParamList = Param
			RETURN3,	// [32] Param = ID DBCOLON TYPE; returns 'TYPE' although none is marked
			Action.RETURN,	// [33] Lvalue = ID.l
			RETURN4,	// [34] Lvalue = Lvalue LB Exp RB; returns 'RB' although none is marked
			RETURN3,	// [35] Lvalue = Lvalue DOT ID; returns 'ID' although none is marked
			Action.RETURN,	// [36] Exp = Rexp
			new Action() {	// [37] Rexp = Exp.l GREATER Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Greater(l, r);
				}
			},
			new Action() {	// [38] Rexp = Exp.l LESSER Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Lesser(l, r);
				}
			},
			new Action() {	// [39] Rexp = Exp.l GREATEREQUAL Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new GreaterEqual(l, r);
				}
			},
			new Action() {	// [40] Rexp = Exp.l LESSEREQUAL Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new LesserEqual(l, r);
				}
			},
			new Action() {	// [41] Rexp = Exp.l EQUALTO Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Equal(l, r);
				}
			},
			new Action() {	// [42] Rexp = Exp.l DIF Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Dif(l, r);
				}
			},
			new Action() {	// [43] Rexp = Exp.l AND Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new And(l, r);
				}
			},
			Action.RETURN,	// [44] Rexp = Aexp
			new Action() {	// [45] Aexp = Exp.l PLUS Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Add(l, r);
				}
			},
			new Action() {	// [46] Aexp = Exp.l SUB Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Sub(l, r);
				}
			},
			Action.RETURN,	// [47] Aexp = Mexp
			new Action() {	// [48] Mexp = Exp.l MULT Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Mult(l, r);
				}
			},
			new Action() {	// [49] Mexp = Exp.l DIV Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Div(l, r);
				}
			},
			new Action() {	// [50] Mexp = Exp.l MOD Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Mod(l, r);
				}
			},
			Action.RETURN,	// [51] Mexp = Sexp
			RETURN2,	// [52] Sexp = Exp NOT; returns 'NOT' although none is marked
			new Action() {	// [53] Sexp = BOOL.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final boolean n = (boolean) _symbol_n.value;
					return new LiteralValue<Boolean>(n);
				}
			},
			Action.RETURN,	// [54] Sexp = NULL
			new Action() {	// [55] Sexp = INT.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					return new LiteralValue<Integer>(n);
				}
			},
			new Action() {	// [56] Sexp = FLOAT.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final float n = (float) _symbol_n.value;
					return new LiteralValue<Float>(n);
				}
			},
			new Action() {	// [57] Sexp = CHAR.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Character n = (Character) _symbol_n.value;
					return new LiteralValue<Character>(n);
				}
			},
			Action.RETURN,	// [58] Sexp = Pexp
			RETURN3,	// [59] Pexp = AP Exp FP; returns 'FP' although none is marked
			RETURN4,	// [60] Pexp = TYPE LB Exp RB; returns 'RB' although none is marked
			new Action() {	// [61] Pexp = ID.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					return new Var(l);
				}
			},
			new Action() {	// [62] lst$Exp = Exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [63] lst$Exp = lst$Exp Exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.RETURN	// [64] Exps = lst$Exp
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
