package src.parsers;

import src.ast.*;
import java.util.ArrayList;
import src.beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "lang.grammar".
 */
public class MiniLangParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pTLsbiL5KK$jvxrDeD2ZX2RQVJpIwqr7RQAQM01QmKKB6eAE12eRAue8YeLG6HFoR#C24" +
		"ccfZunyGVw3yJ$YWn0cfLh0ieWbj1HL7SgY9kUFpcpIMzSzzx7MfD24xotU$SSyuzzzvpjp" +
		"U0irp#HYQQC1brg4SK3MYKlqmDHk1yLA0Ars85RiLjMAFg8mSqyeUdrTL6N46R$8XsEQx5Q" +
		"PD3QDVgw#Kh5NiSGiX3FiA8e1Ybg9R3dXxQv0JZ$OaxCSsmc2FrHZiMPC4vgC54rE82nD0S" +
		"w1MalqH#nrHpxinKDcPY5cxHOj#5Ap4$zKXnhjRc1azaizw676Oq5tThaKTXDCQSGazhjPv" +
		"kyaI#8x1Twcpt1rf#2BHyPsJBaLzXuooSRQwsl3JaLJfTUcD6c8iqTqQcVWxIVVKjo73rYp" +
		"NzU4s#5DFHYXcu7mizUss1vvIO7fqUpOsomzFgJAi$E4H$FRUchPKhTX5pEtWcRnxscFMJU" +
		"9ucpvPlS1dMeK3J5MfoaIQNQ7AP9fThSgKcJz3aIPeyHPClrkH5cdoz9g$IvDir#HvDlb1#" +
		"aSzn3JPW7kv5D$VhvRW27RXAZk0w#HdBi0HBqONbM8cvyXDMerk#bpvaIH$BiSHzBB#KBx1" +
		"HFiC3s4G05ky7XwzL$4obyvHuDI6UdqnayKuTntEJnzmcwfQcyRRonWqpKeIhCD0gp7CUqU" +
		"ebj2PYP$D67iaxEDUzXSVoVGbv8eOPCqAKU2pcIFsY1LdAUGjLyXwQm9idFz0hI5$3yPJwv" +
		"AAPExKqANPYNLEFD7aygR8SPWOZr1HhaOius#PXznGBR3USR0zcCRDLm5CGF#tco5g6l4gd" +
		"Is$Eo58pClKv0VgmZrwNerotHlRRnBl8kzVCl7azl9hKE#x$LjTpODeQgQbXRbDbyhySG$9" +
		"uGboHMA3zJ95jpgEGPPJVV2MSUHFVxm9gGYpZjZBA1IviTyurz0bnznVoRWlpRelGlzYDOJ" +
		"4VHRGMyTxTl0dkRm4H4#7$dCHl2P51B2NAYAs0Cvdy7D6hskmXZX2VkkyKh1RoCc8bvKL43" +
		"c3daXUJnvDNaDcdjPPSITv8hYC$J6vckqpoTF8Oykn47tQ7ueLn7WhOffF5keHiFS$wAWeF" +
		"QVOrrFSI7B$zEFb5AlCeTvCVLJxx5EzISvv1cNvEFj5AS1vuXboLi3jH5dpFd3YcqfTgwnZ" +
		"n6F4KTUtKFKAVxPHhoH#GwuaAWhb07xc1Y17pwFi4TVricytwD78XkSDzls6pNwkQp3Lnud" +
		"aZRCxJcKDvD#MTj3El3jzxPpx1iNFlmE7QEhE8cKId6dURobFbG7wiBOgVLBnrm8Rr$Zd7T" +
		"iLTYfzLRLzGULHrUvlYa$eTYdiKgprcxrLyG76VNx#3WMqE6$MZoNLhcpulsbShl$vJY##C" +
		"Lcst675xj3wxYEF6E4vellkDjeUCFXpLPeEcgr2SeVe$gCL#MlCRfSbLcfpZFnziXizFNdR" +
		"BtppwZuWFYGF4Ve8xMlOHxn5xYNU9TuYtfLS#blTbZxmbRyfkUKDUbzUanutngehrIg8NLJ" +
		"lgbZoTyWdH9zyczVjrqhXsoYw$KV#xdnnqexRoAod#jM4J3d5IJd0ztvvc5sbylHmYdSWYq" +
		"jpNR29z1k3mMzOYRDUlZdThBNMrhCV8CTeQo0taA3bARYBNk6$d2FSkBwTSGVQ7nNV2KR3u" +
		"OZWQBBuVDc7vefe#rUmZ$b9ESc6xR$QKVm2vFW2w");

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};

	private final Action[] actions;

	public MiniLangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = Prog
			new Action() {	// [1] Prog = Stmt.l SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [2] Prog = Stmt.l SEMI Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			new Action() {	// [3] Prog = Func.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [4] Prog = Func.l Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			new Action() {	// [5] Prog = Data.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [6] Prog = Data.l Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			RETURN4,	// [7] Data = ID AC Decl FC; returns 'FC' although none is marked
			RETURN4,	// [8] Decl = ID DBCOLON TYPE SEMI; returns 'SEMI' although none is marked
			RETURN5,	// [9] Decl = ID DBCOLON TYPE SEMI Decl; returns 'Decl' although none is marked
			new Action() {	// [10] Stmt = ID.l EQ Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					 return new Attr((String)l, r);
				}
			},
			new Action() {	// [11] Stmt = IF AP Exp.l FP AC StmtList.r FC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 3];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 6];
					final Node r = (Node) _symbol_r.value;
					 return new IfElse(l, r);
				}
			},
			new Action() {	// [12] Stmt = IF AP Exp.l FP AC StmtList.r FC ELSE AC StmtList.s FC
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 3];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 6];
					final Node r = (Node) _symbol_r.value;
					final Symbol _symbol_s = _symbols[offset + 10];
					final Node s = (Node) _symbol_s.value;
					 return new IfElse(l, r, s);
				}
			},
			RETURN5,	// [13] Stmt = ITERATE AP Exp FP Stmt; returns 'Stmt' although none is marked
			Action.RETURN,	// [14] Stmt = Exp
			RETURN2,	// [15] Stmt = READ Lvalue; returns 'Lvalue' although none is marked
			new Action() {	// [16] Stmt = PRINT Exp.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 return new Print(e);
				}
			},
			RETURN2,	// [17] Stmt = RETURN Ret; returns 'Ret' although none is marked
			RETURN3,	// [18] Stmt = Lvalue EQ Exp; returns 'Exp' although none is marked
			new Action() {	// [19] lst$Lvalue = Lvalue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [20] lst$Lvalue = lst$Lvalue Lvalue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			RETURN7,	// [21] Stmt = ID AP Exps FP LESSER lst$Lvalue GREATER; returns 'GREATER' although none is marked
			RETURN8,	// [22] Func = ID.a AP ParamList.b FP COLON Return AC StmtList.c FC; returns 'c' although more are marked
			new Action() {	// [23] StmtList = Stmt.l SEMI StmtList.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Node r = (Node) _symbol_r.value;
					 return new StmtList(l, r);
				}
			},
			new Action() {	// [24] StmtList = Stmt.l SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new StmtList(l);
				}
			},
			RETURN3,	// [25] Ret = Exp COMMA Ret; returns 'Ret' although none is marked
			Action.RETURN,	// [26] Ret = Exp
			RETURN3,	// [27] Return = TYPE COMMA Return; returns 'Return' although none is marked
			Action.RETURN,	// [28] Return = TYPE
			RETURN3,	// [29] ParamList = Param COMMA ParamList; returns 'ParamList' although none is marked
			Action.RETURN,	// [30] ParamList = Param
			RETURN3,	// [31] Param = ID DBCOLON TYPE; returns 'TYPE' although none is marked
			Action.RETURN,	// [32] Lvalue = ID.l
			RETURN4,	// [33] Lvalue = Lvalue LB Exp RB; returns 'RB' although none is marked
			RETURN3,	// [34] Lvalue = Lvalue DOT ID; returns 'ID' although none is marked
			Action.RETURN,	// [35] Exp = Rexp
			new Action() {	// [36] Rexp = Exp.l GREATER Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Greater(l, r);
				}
			},
			new Action() {	// [37] Rexp = Exp.l LESSER Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Lesser(l, r);
				}
			},
			new Action() {	// [38] Rexp = Exp.l GREATEREQUAL Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new GreaterEqual(l, r);
				}
			},
			new Action() {	// [39] Rexp = Exp.l LESSEREQUAL Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new LesserEqual(l, r);
				}
			},
			new Action() {	// [40] Rexp = Exp.l EQUALTO Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Equal(l, r);
				}
			},
			new Action() {	// [41] Rexp = Exp.l DIF Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Dif(l, r);
				}
			},
			Action.RETURN,	// [42] Rexp = Aexp
			new Action() {	// [43] Aexp = Exp.l PLUS Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Add(l, r);
				}
			},
			new Action() {	// [44] Aexp = Exp.l SUB Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Sub(l, r);
				}
			},
			Action.RETURN,	// [45] Aexp = Mexp
			new Action() {	// [46] Mexp = Exp.l MULT Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Mult(l, r);
				}
			},
			new Action() {	// [47] Mexp = Exp.l DIV Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Div(l, r);
				}
			},
			new Action() {	// [48] Mexp = Exp.l RES Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Res(l, r);
				}
			},
			Action.RETURN,	// [49] Mexp = Sexp
			RETURN2,	// [50] Sexp = Exp NOT; returns 'NOT' although none is marked
			new Action() {	// [51] Sexp = BOOL.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final boolean n = (boolean) _symbol_n.value;
					return new LiteralValue<Boolean>(n);
				}
			},
			Action.RETURN,	// [52] Sexp = NULL
			new Action() {	// [53] Sexp = INT.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					return new LiteralValue<Integer>(n);
				}
			},
			new Action() {	// [54] Sexp = FLOAT.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final float n = (float) _symbol_n.value;
					return new LiteralValue<Float>(n);
				}
			},
			new Action() {	// [55] Sexp = CHAR.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final char n = (char) _symbol_n.value;
					return new LiteralValue<Character>(n);
				}
			},
			Action.RETURN,	// [56] Sexp = Pexp
			RETURN3,	// [57] Pexp = AP Exp FP; returns 'FP' although none is marked
			RETURN4,	// [58] Pexp = TYPE LB Exp RB; returns 'RB' although none is marked
			new Action() {	// [59] Pexp = ID.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					return new Var(l);
				}
			},
			new Action() {	// [60] lst$Exp = Exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [61] lst$Exp = lst$Exp Exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.RETURN	// [62] Exps = lst$Exp
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
