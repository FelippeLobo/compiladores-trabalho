package src.parsers;

import src.ast.*;
import java.util.ArrayList;
import src.beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "lang.grammar".
 */
public class MiniLangParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pTLrbm5KKKFJCDFeWaG1P04XD8I6B80q8CMP500gAYeWY26XH5n0N5k88BMAK$bfO5$bc" +
		"bLMuV#ADLbbLM#IE88fiRRhWHbu0A2hY18dezCw$ZkyoyuRqKPQcyrEbp#lRjszrtPhexW5" +
		"aeVs8XngCErOXZ3CPYd1mEMZ0D8r2AKJWBvsCkBi8bjZurQP53eLuNeXAde0gZKOC5o891N" +
		"vo0VYAXEBaOX7mCmJ0CHn6AKI4xGz5QqURZKZG6MfBHmYEwteZ83gnmRGhFcE#PVcQ$HBLW" +
		"e8fvQgHNbDrRMmFwo1#uF3XVJ8dibSp$xpWdjCxVqlV3YPWT6Y#SdVv#TYPaa9yV8blsHRP" +
		"y7vf1ImOpxss6$otxcIgRWvM#7XFHp6$hTamFPNn0w2qFUfmRifmdwqAscq9nZhUwpcwmhH" +
		"cJqCxifejnPDRc7FESxWxKvwluIijNyWMMemEtocw#1JEm39SXJ$aMA3rKwPEKBbJwPALBb" +
		"1wfT9dIvKhNAbslz6Ibpr3wRAKlKFfYfQzGUedin#beaf#nM7x2B6#$an$vzi#JlR8Bfs4n" +
		"5k4gN8EPk1PNuphS80UaIxfmfL$cO2bkGOuSn8tefBePjqatxi1TyYNkv1$WSAytwEEVCJ7" +
		"kLM6BmrqiY$lT4EPo67CutDQpbINSg#BlDIIVPmsVBq9n1Z1I3a#1GVpAS$aSy$dyWj6A#8" +
		"myb8PQaj6YHWpsQ8xqp6HcKIqwPc6aLvJTMriPeuFlN72#PP6zTFuBKpp9zFqAKlIBoaxHC" +
		"UNdQ2t16KJdB$qC$cjsdKsjQ#bRnvNNy$OIpdZwPnAs56OGvtYhwnK7s#gO0uVPxKqCBsl$" +
		"v1orBkOJg#NTi9HVG3txb597#VxVjSirnltI8Ln$l$Dqd6K1cgWQUV8Qdgm5l0ysCZCbla#" +
		"nNuxa$T2mBE7$1yLK2NQe2kazWZlTYdlW$sOGJSJpYIes#hiWq4sC8lOIUuZEXB#Pm68USI" +
		"yFi7r4Et6Gc4q8iG1mO#Gbv87aPUIXvFl89UoNHQuavvB79MAw3PPRFUuDs6SwYrLsBOTOd" +
		"qb#IhNFvTWr1DVdl4p3OAAHzaNavwpFKilFsZZDzDr2h28UfNqzqKdxPc8JSr16taak9vWx" +
		"Tpdhk#Zhi5v5pYDF8fXdztxMFLxDUfn#zTIFK8#XNaFz1DkfJIt1N9fAc#VHn5IYZk1ypLZ" +
		"wFaFcVS1mFMOMqSA#RUI9TlwFKtEzffNwQV9yOXenXUYmSTli6YSdSuIOvJcMkvDjpcFARw" +
		"MrhRRZFMbvpP7vSr#m$9BbjPOtMDvgUPlbxJrZP0hssH6eTmVgpKbjl7UktTftfucxFr0$O" +
		"DTir#QygDeEM#vGO#LRTctRWyh$OUNNJ#dir7CnUNRC1vIjtDhM1Nohr3WFfOw75KZvaw$b" +
		"6tdLwa#8ZucFYEt4XyG7n7l4kyGxnDl4M$A6V2hlopPvKxRA5jaicsIZlEx7s61ZlTOJrQ$" +
		"jySiTn6T4btp7yXLPdtfEH$ibeiglaUtVXYoV#trQ#MKxl9kvX25wT8B7ymHgzD6NPveXF8" +
		"vPTWXNmVXxS9ElOxpjzUVTmH0kpoH3EDnn3U7mn3A4Tsyn$laQvnXnwWhgId9gE3m9Z8N3C" +
		"y4eE3mXNC99YMhwL7ECQdkMDz3NkpUr$0KYmEEq");

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	private final Action[] actions;

	public MiniLangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = Prog
			new Action() {	// [1] Prog = StmtList.l SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [2] Prog = StmtList.l SEMI Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			new Action() {	// [3] Prog = Func.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [4] Prog = Func.l Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			new Action() {	// [5] Prog = Data.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					 return new Prog(l);
				}
			},
			new Action() {	// [6] Prog = Data.l Prog.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Node l = (Node) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final Node r = (Node) _symbol_r.value;
					 return new Prog(l, r);
				}
			},
			RETURN4,	// [7] Data = ID AC Decl FC; returns 'FC' although none is marked
			RETURN4,	// [8] Decl = ID DBCOLON TYPE SEMI; returns 'SEMI' although none is marked
			RETURN5,	// [9] Decl = ID DBCOLON TYPE SEMI Decl; returns 'Decl' although none is marked
			new Action() {	// [10] Stmt = ID.l EQ Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					 return new Attr((String)l, r);
				}
			},
			RETURN5,	// [11] Stmt = IF AP Exp FP StmtList; returns 'StmtList' although none is marked
			RETURN7,	// [12] Stmt = IF AP Exp FP StmtList ELSE StmtList; returns 'StmtList' although none is marked
			RETURN5,	// [13] Stmt = ITERATE AP Exp FP Stmt; returns 'Stmt' although none is marked
			Action.RETURN,	// [14] Stmt = Exp
			RETURN2,	// [15] Stmt = READ Lvalue; returns 'Lvalue' although none is marked
			new Action() {	// [16] Stmt = PRINT Exp.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 return new Print(e);
				}
			},
			RETURN2,	// [17] Stmt = RETURN Ret; returns 'Ret' although none is marked
			RETURN3,	// [18] Stmt = Lvalue EQ Exp; returns 'Exp' although none is marked
			new Action() {	// [19] lst$Lvalue = Lvalue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [20] lst$Lvalue = lst$Lvalue Lvalue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			RETURN7,	// [21] Stmt = ID AP Exps FP LESSER lst$Lvalue GREATER; returns 'GREATER' although none is marked
			RETURN9,	// [22] Func = ID AP ParamList FP COLON Return AC StmtList FC; returns 'FC' although none is marked
			RETURN3,	// [23] StmtList = Stmt SEMI StmtList; returns 'StmtList' although none is marked
			RETURN2,	// [24] StmtList = Stmt SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [25] Ret = Exp COMMA Ret; returns 'Ret' although none is marked
			Action.RETURN,	// [26] Ret = Exp
			RETURN3,	// [27] Return = TYPE COMMA Return; returns 'Return' although none is marked
			Action.RETURN,	// [28] Return = TYPE
			RETURN3,	// [29] ParamList = Param COMMA ParamList; returns 'ParamList' although none is marked
			Action.RETURN,	// [30] ParamList = Param
			RETURN3,	// [31] Param = ID DBCOLON TYPE; returns 'TYPE' although none is marked
			Action.RETURN,	// [32] Lvalue = ID.l
			RETURN4,	// [33] Lvalue = Lvalue LB Exp RB; returns 'RB' although none is marked
			RETURN3,	// [34] Lvalue = Lvalue DOT ID; returns 'ID' although none is marked
			Action.RETURN,	// [35] Exp = Rexp
			RETURN3,	// [36] Rexp = Exp GREATER Exp; returns 'Exp' although none is marked
			RETURN3,	// [37] Rexp = Exp LESSER Exp; returns 'Exp' although none is marked
			RETURN3,	// [38] Rexp = Exp GREATEREQUAL Exp; returns 'Exp' although none is marked
			RETURN3,	// [39] Rexp = Exp LESSEREQUAL Exp; returns 'Exp' although none is marked
			RETURN3,	// [40] Rexp = Exp EQUALTO Exp; returns 'Exp' although none is marked
			RETURN3,	// [41] Rexp = Exp DIF Exp; returns 'Exp' although none is marked
			Action.RETURN,	// [42] Rexp = Aexp
			new Action() {	// [43] Aexp = Exp.l PLUS Exp.r
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final Exp l = (Exp) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final Exp r = (Exp) _symbol_r.value;
					return new Add(l, r);
				}
			},
			RETURN3,	// [44] Aexp = Exp SUB Exp; returns 'Exp' although none is marked
			Action.RETURN,	// [45] Aexp = Mexp
			RETURN3,	// [46] Mexp = Exp MULT Exp; returns 'Exp' although none is marked
			RETURN3,	// [47] Mexp = Exp DIV Exp; returns 'Exp' although none is marked
			RETURN3,	// [48] Mexp = Exp RES Exp; returns 'Exp' although none is marked
			Action.RETURN,	// [49] Mexp = Sexp
			RETURN2,	// [50] Sexp = Exp NOT; returns 'NOT' although none is marked
			Action.RETURN,	// [51] Sexp = BOOL
			Action.RETURN,	// [52] Sexp = NULL
			new Action() {	// [53] Sexp = INT.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					return new Num(n);
				}
			},
			Action.RETURN,	// [54] Sexp = FLOAT
			Action.RETURN,	// [55] Sexp = CHAR
			Action.RETURN,	// [56] Sexp = Pexp
			RETURN3,	// [57] Pexp = AP Exp FP; returns 'FP' although none is marked
			RETURN4,	// [58] Pexp = TYPE LB Exp RB; returns 'RB' although none is marked
			new Action() {	// [59] Pexp = ID.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					return new Var(l);
				}
			},
			new Action() {	// [60] lst$Exp = Exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [61] lst$Exp = lst$Exp Exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.RETURN	// [62] Exps = lst$Exp
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
