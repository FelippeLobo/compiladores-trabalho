package src.parsers;

import src.ast.*;
import java.util.ArrayList;
import src.beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Exemplo.grammar".
 */
public class MiniLangParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9p5apapH44KXSzOnXZhZ6KmRyQ#hu5GA1GAXH9LGY82eL16mWyGaOX48f4gCQNi#xxlrvc" +
		"PLkwyHmsbYdxrrJct#zwkxdxT06vHYm8K8e0YX96C916ao1Ogu4OfYb6282o4xB4ysUfQqU" +
		"2eYSz8vNYDRSx$ZTEG0n$oa8uCPCczYUeIxACbhkfPHt6#7DNmg4glyZelK$LdAv#hl5$vV" +
		"ENBbAzop5#9UZIZKHxH90#0t9dnZvs1cMLm8OdxIk4VSlDCF8xOvwWBEtBi6Odc$EiudwVj" +
		"vNbdyiIpkUjOb9Tm7vzLnIBj2$YtTANsEk#hdD$usFn#VZxUMXzNaiCtdCj$spQ2QFCJZmZ" +
		"l0L1b#lf8EnaZ7MIMT99XqaKsIBV9xJ7Q6z7lmjPFnerV8GDaKeqFabNY9MjaasoJKR93rY" +
		"DvNFUXgWaeFs5qokYqqHcZSqRdZIxySFsBjdZfYpmtMLRnaF9jC4rUv5MsZRyXL#IId9CpS" +
		"YgtSYqNSYB7SYI7SY3xiXVDtZLLE#$rjcP5tt28zpZ4ssnHm#oDl56BQxEefUmlf0Ou5g0M" +
		"KMEuU8kI5IxUgSy9SZp8bnAaBty3vc2Sz0==");

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	private final Action[] actions;

	public MiniLangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] Prog = StmtList
			RETURN3,	// [1] StmtList = Stmt SEMI StmtList; returns 'StmtList' although none is marked
			RETURN2,	// [2] StmtList = Stmt SEMI; returns 'SEMI' although none is marked
			RETURN3,	// [3] Stmt = ID EQ Exp; returns 'Exp' although none is marked
			Action.NONE,  	// [4] opt$StmtList = 
			Action.RETURN,	// [5] opt$StmtList = StmtList
			RETURN6,	// [6] Stmt = Exp IF LB opt$StmtList Els RB; returns 'RB' although none is marked
			Action.RETURN,	// [7] Stmt = Exp
			RETURN2,	// [8] Els = COLON StmtList; returns 'StmtList' although none is marked
			Action.RETURN,	// [9] Exp = Rexp
			RETURN3,	// [10] Rexp = Exp GREATER Exp; returns 'Exp' although none is marked
			Action.RETURN,	// [11] Rexp = Aexp
			RETURN3,	// [12] Aexp = Exp PLUS Exp; returns 'Exp' although none is marked
			RETURN3,	// [13] Aexp = Exp SUB Exp; returns 'Exp' although none is marked
			Action.RETURN,	// [14] Aexp = Mexp
			RETURN3,	// [15] Mexp = Exp MULT Exp; returns 'Exp' although none is marked
			RETURN3,	// [16] Mexp = Exp DIV Exp; returns 'Exp' although none is marked
			RETURN3,	// [17] Mexp = Exp RES Exp; returns 'Exp' although none is marked
			Action.RETURN,	// [18] Mexp = Sexp
			Action.RETURN,	// [19] Sexp = BOOL
			Action.RETURN,	// [20] Sexp = NULL
			Action.RETURN,	// [21] Sexp = INT
			Action.RETURN,	// [22] Sexp = FLOAT
			Action.RETURN,	// [23] Sexp = CHAR
			Action.RETURN,	// [24] Sexp = Pexp
			RETURN3,	// [25] Pexp = AP Exp FP; returns 'FP' although none is marked
			RETURN4,	// [26] Pexp = TYPE LB Exp RB; returns 'RB' although none is marked
			Action.RETURN	// [27] Pexp = ID
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
