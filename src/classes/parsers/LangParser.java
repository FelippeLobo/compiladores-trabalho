package classes.parsers;

import classes.ast.*;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "lang.grammar".
 */
public class LangParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjc4jm55KKXl$koHWnW8Z0p62CanX6X4oOF40GDH6V#4H54OLW54I1dQxKAhNAXLPPvSR" +
		"IZUvWfIjrusDZbLMKXO9lHOc2uXFV6X4LhrztZadV2VOuRcDt$VS$$pdtdhxSstDk1oaJgg" +
		"m5EaadwWIrwcJDqIawLVFLfHxrEgV9QN4rwFZKU1IxICjqdfReT2tL6JfJirD7NAPpK#Dzk" +
		"aeBjKYdQR7ESdzgfIxLyffpM9tQunWThHjgvfYeCM$5THmhVhMkqInTCcvdQsXtM8CwM#Vh" +
		"0bsi6zrENLcLUmsvRyBNbF1DqZGTfPbQfUlgVTw4r$xgNguLTOuOrFKrHmngFM$31ctKhTZ" +
		"9tHeastGlsyYLx9EqrtggiQfddmg9N7rgzbIBfugUQlDKkwTAdfhhgNcUwl1KfwSgdkhsr3" +
		"cUkj1JLwIeQrDYwn9gRNpdMQqSROPxYa9brUzUnTyVnpPfW3qwbZupK7cyqNKpk0NqSq#Y1" +
		"ZPHwwTeAlscyIkVJcMVmThFeaS#DLwe4OzY0NFAS5fasSz6gcrhweXyZOmbwjDSAjGyQbG7" +
		"y#kaUgLdZ6A5r1uXTI#znqIE#IiUnYiUuEqUjxErjF04$2Pp#4FskRKgTo7ExVjcSourSpg" +
		"rS4RL#xo9hlsLpB6wzOq8$iM8W7qCU7TAx5vGjLjLsLnyUNsITibJvQgUVgx$rPYAxXohLM" +
		"27o$5TuIxo$LQY9GRQsOreHSked8hnFdH5N$YWo2rjlYS#6CB9D5D1bX$hGdW0NmkyRYIkk" +
		"$6lPFX1$EqsPlu81pF16WpExx37V0Ni7MQlZqugixVGt0dV3Zy0tmK$2jy7RuCVX9#67uPV" +
		"X1#3Ty5RuJdma$16#1dBzuBnIpH3aLqFcEDknYwo7A$GLCpc30pQm5lHQMc#nM0FnWBJGs0" +
		"$Q4OSi7KwX6uVonyCqwms#p3eiEVk1D5wRxBO4ZJF3AcMOGuKmOzWBsYoCVkCdqtC$pdZ5l" +
		"$V5RIP$tdZxOanZSOlsvo74x5omkurNcgyp7YvyGhZLSO3nXkCjnZVPdo7yRt9kVuNaEF#8" +
		"$WUyhM#0brZEjXEdqUgnZoUiBSc#kv5Fv68FUMF2$A9s8veRyVFHvjLTRa$HgtVmM#Zwb3S" +
		"$XgttuAl0RDtNu8lmEVWC$0f#0Hy39YX#mXywFQu3zm1jz$jSqFkVRVRlUVUTU#ujntlhli" +
		"cpldcw9FUSD$5$9hfORVB$GA$Rlw3SVkpHNyQyPhw0NplU2lv1kYXibGu4IgA$ZSX0xAWqJ" +
		"WJepC#IVwED$2tPG0Y7PquqJdH03BKjGW1rItp3mYeUnb3G0NC911G3qD3S4HqnCY0RFprq" +
		"atV3kOQVS$q$WKvJSTH");

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] Prog = CmdList.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Node s = (Node) _symbol_s.value;
					  return s;
				}
			},
			new Action() {	// [1] CmdList = Cmd.s SEMICOLON CmdList.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Node s = (Node) _symbol_s.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final Node l = (Node) _symbol_l.value;
					 return new CmdList(s,l);
				}
			},
			new Action() {	// [2] CmdList = Cmd.s SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Node s = (Node) _symbol_s.value;
					 return s;
				}
			},
			new Action() {	// [3] Cmd = LBRACE Cmd.c RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 2];
					final Node c = (Node) _symbol_c.value;
					 return c;
				}
			},
			new Action() {	// [4] Cmd = IF LPAREN Exp.e RPAREN Cmd.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Node c = (Node) _symbol_c.value;
					 return new If(e, c);
				}
			},
			new Action() {	// [5] Cmd = IF LPAREN Exp.e RPAREN Cmd.c ELSE Cmd.m
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Node c = (Node) _symbol_c.value;
					final Symbol _symbol_m = _symbols[offset + 7];
					final Node m = (Node) _symbol_m.value;
					 return new If(e, c, m);
				}
			},
			new Action() {	// [6] Cmd = ITERATE LPAREN Exp.e RPAREN Cmd.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Node c = (Node) _symbol_c.value;
					 return new Iterate(e, c);
				}
			},
			new Action() {	// [7] Cmd = READ Lvalue.l SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 2];
					final String l = (String) _symbol_l.value;
					 return new Read(l);
				}
			},
			new Action() {	// [8] Cmd = PRINT Exp.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 return new Print(e);
				}
			},
			new Action() {	// [9] lst$Exp = Exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [10] lst$Exp = lst$Exp Exp
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [11] Cmd = RETURN lst$Exp.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final ArrayList _list_e = (ArrayList) _symbol_e.value;
					final Exp[] e = _list_e == null ? new Exp[0] : (Exp[]) _list_e.toArray(new Exp[_list_e.size()]);
					 return new Return(e);
				}
			},
			new Action() {	// [12] Cmd = Lvalue.l EQUAL Exp.e SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					 return new Attr(l, e);
				}
			},
			new Action() {	// [13] lst$Lvalue = Lvalue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [14] lst$Lvalue = lst$Lvalue Lvalue
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			RETURN6,	// [15] Cmd = ID.x LPAREN Exps.e RPAREN LESSER lst$Lvalue.v GREATER SEMICOLON; returns 'v' although more are marked
			new Action() {	// [16] Lvalue = ID.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new ID(i);
				}
			},
			new Action() {	// [17] Lvalue = Lvalue.v LBRACK Exp.e RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					 return new Call(v, e);
				}
			},
			new Action() {	// [18] Lvalue = Lvalue.v DOT ID.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final String i = (String) _symbol_i.value;
					 return new Call(v, i);
				}
			},
			new Action() {	// [19] Exp = Exp.a AND Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new And(a, b);
				}
			},
			Action.RETURN,	// [20] Exp = Rexp
			new Action() {	// [21] Rexp = Exp.a GREATER Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Greater(a, b);
				}
			},
			new Action() {	// [22] Rexp = Exp.a LESSER Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Lesser(a, b);
				}
			},
			new Action() {	// [23] Rexp = Exp.a GREATEREQUAL Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new GreaterEqual(a, b);
				}
			},
			new Action() {	// [24] Rexp = Exp.a LESSEREQUAL Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new LesserEqual(a, b);
				}
			},
			new Action() {	// [25] Rexp = Exp.a EQUALTO Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Equal(a, b);
				}
			},
			new Action() {	// [26] Rexp = Exp.a DIF Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Diff(a, b);
				}
			},
			Action.RETURN,	// [27] Rexp = Aexp
			new Action() {	// [28] Aexp = Exp.a ADD Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [29] Aexp = Exp.a SUB Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			Action.RETURN,	// [30] Aexp = Mexp
			new Action() {	// [31] Mexp = Exp.a MULT Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Mul(a,b);
				}
			},
			new Action() {	// [32] Mexp = Exp.a DIV Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [33] Mexp = Exp.a RES Exp.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new Res(a, b);
				}
			},
			Action.RETURN,	// [34] Mexp = Sexp
			new Action() {	// [35] Sexp = Exp.a NOT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					 return new Not(a);
				}
			},
			new Action() {	// [36] Sexp = Exp.a TRA
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					 return new Tra(a);
				}
			},
			Action.RETURN,	// [37] Sexp = BOOL
			Action.RETURN,	// [38] Sexp = NULL
			Action.RETURN,	// [39] Sexp = INT
			Action.RETURN,	// [40] Sexp = FLOAT
			Action.RETURN,	// [41] Sexp = CHAR
			Action.RETURN,	// [42] Sexp = Pexp
			Action.RETURN,	// [43] Pexp = Lvalue
			RETURN3,	// [44] Pexp = LPAREN Exp RPAREN; returns 'RPAREN' although none is marked
			RETURN5,	// [45] Pexp = NEW TYPE LBRACK Exp RBRACK; returns 'RBRACK' although none is marked
			new Action() {	// [46] lst$Exps = Exps
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [47] lst$Exps = lst$Exps Exps
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			RETURN7,	// [48] Pexp = ID LPAREN lst$Exps RPAREN LBRACK lst$Exp RBRACK; returns 'RBRACK' although none is marked
			Action.RETURN	// [49] Exps = lst$Exp
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
