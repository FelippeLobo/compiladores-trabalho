%package "classes.parsers";
%import "src.classes.ast.*";
%import "src.classes.beaver.*";

%class "LangParser";

%terminals  ID, INT, TYPE, FLOAT, CHAR, BOOL, NULL, 
            ADD, MULT, SUB, DIV, PRINT, READ, RBRACK, 
            LBRACK, RPAREN, LPAREN, RES, EQUAL, EQUALTO, DIF, NOT, TRA,
            GREATER, LESSER, GREATEREQUAL, LESSEREQUAL, AND, OR, DIF, NOT, COLON,
            DOUBLECOLON, SEMICOLON, RBRACE, LBRACE, IF, ELSE, 
            RETURN, NEW, ITERATE, DOT, DATA, COMMA, ELSEIF;

%left RPAREN;
%left MULT, DIV;
%left ADD, SUB;

%embed {: private boolean good;
          
          public boolean isGood(){ return good;}
          
          protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception{
              super.recoverFromError(token, in);
              good = false;
          }
:} ;

%init {: good = true; :} ;

%typeof INT = "Integer";
%typeof TYPE = "String";
%typeof FLOAT = "Float";
%typeof BOOL = "boolean";
%typeof CHAR = "char";
%typeof Exp = "Exp";
%typeof ID = "String";
%typeof Cmd = "Node";
%typeof CmdList = "Node";
%typeof Prog = "Node";
%typeof Lvalue = "String";
%typeof Function = "Function";
%typeof Data = "Data";
%typeof Pexp = "Exp";
%typeof Aexp = "Exp";
%typeof Mexp = "Exp";
%typeof Sexp = "Exp";
%goal Prog;

Prog = Data.a Function.b | CmdList.c               
     ;

CmdList = Cmd.s SEMICOLON CmdList.l     
         | Cmd.s SEMICOLON               
         ;

Cmd = LBRACE Cmd.c RBRACE                         
     | IF LPAREN Exp.e RPAREN Cmd.c             
     | IF LPAREN Exp.e RPAREN Cmd.c ELSE Cmd.m      
     | ITERATE LPAREN Exp.e RPAREN Cmd.c        
     | READ Lvalue.l SEMICOLON                  
     | PRINT Exp.e SEMICOLON                    
     | RETURN Exp.e+ SEMICOLON      
     | Lvalue.l EQUAL Exp.e SEMICOLON               
     | ID.x LPAREN Exps.e RPAREN LESSER Lvalue.v+ GREATER SEMICOLON                      
     ;



Lvalue = ID.i 
     | Lvalue.v LBRACK Exp.e RBRACK  
     | Lvalue.v DOT ID.i   
      ;

Exp = Exp.a AND Exp.b             
     | Exp.a OR Exp.b             
     | Rexp.e                     
;

Rexp = Exp.a GREATER Exp.b         
     | Exp.a LESSER Exp.b          
     | Exp.a GREATEREQUAL Exp.b    
     | Exp.a LESSEREQUAL Exp.b     
     | Exp.a EQUALTO Exp.b         
     | Exp.a DIF Exp.b            
     | Aexp.a                       
;

Aexp = Exp.a ADD  Exp.b            
     | Exp.a SUB Exp.b             
     | Mexp.a                     
;

Mexp = Exp.a MULT  Exp.b           
     | Exp.a DIV Exp.b             
     | Exp.a RES Exp.b             
     | Sexp.a;
;

Sexp = Exp.a NOT                    
     | Exp.a TRA                    
     | BOOL.a                        
     | NULL.a                     
     | INT.a                       
     | FLOAT.a                          
     | CHAR.a                           
     | Pexp.a                           
;

Pexp = Lvalue.a                                   
     | LPAREN Exp.a RPAREN                        
     | NEW TYPE.a LBRACK Exp.b RBRACK             
     | ID.a LPAREN Exps.b RPAREN LBRACK Exp.c RBRACK 
;

Exps = Exp.a+ 
;

Type = TYPE.a 
     | Btype.a  
;

Btype = INT.a  
 | CHAR.a  
  | FLOAT.a  
   | BOOL.a  
    | ID.a  
;

Parameter = ID.a DOUBLECOLON Type.b COMMA; 
Parameters = Parameter.a+               ;

Ret =  Type.a SEMICOLON COMMA    ;
Rets = Ret.a+ ;

Function = ID.a LPAREN Parameters.b RPAREN DOUBLECOLON Rets.c LBRACE CmdList.d RBRACE ;

Decl = ID.a DOUBLECOLON Type.b SEMICOLON    ;
Decls = Decl.a+             ;              

Data = DATA ID.a LBRACK Decls.b RBRACK  ;